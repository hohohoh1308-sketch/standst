<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЕГЭ Информатика - Решатель заданий с ИИ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --ai-color: #9b59b6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 1.5rem 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            font-size: 2rem;
            color: var(--light);
        }

        .logo h1 {
            font-size: 1.8rem;
        }

        .logo .ai-badge {
            background: var(--ai-color);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            padding: 0.5rem 0.8rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        nav a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .main-container {
            display: flex;
            margin-top: 2rem;
            gap: 2rem;
        }

        .sidebar {
            flex: 0 0 280px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            height: fit-content;
            position: sticky;
            top: 100px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }

        .task-selector h3 {
            margin-bottom: 1.2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
        }

        .task-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.8rem;
        }

        .task-btn {
            background: var(--light);
            border: 2px solid #ddd;
            border-radius: 6px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .task-btn:hover {
            background: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }

        .task-btn.active {
            background: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }

        .task-types {
            margin-top: 1.5rem;
        }

        .task-types select {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .variant-selector {
            margin-top: 1rem;
        }

        .variant-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .variant-btn {
            padding: 0.5rem 0.8rem;
            background: #f1f1f1;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .variant-btn.active {
            background: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }

        .content {
            flex: 1;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            min-height: 80vh;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .task-header h2 {
            color: var(--primary);
        }

        .task-number {
            background: var(--secondary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
        }

        .task-tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid #eee;
            overflow-x: auto;
            flex-wrap: nowrap;
        }

        .tab-btn {
            padding: 0.8rem 1.5rem;
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            color: #777;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-btn.active {
            color: var(--secondary);
            border-bottom: 3px solid var(--secondary);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .task-content {
            line-height: 1.8;
        }

        .task-content h3 {
            color: var(--primary);
            margin: 1.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .task-content h4 {
            color: var(--secondary);
            margin: 1.2rem 0 0.8rem;
        }

        .task-condition {
            background: #f9f9f9;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--secondary);
            margin-bottom: 1.5rem;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
        }

        .code-block code {
            display: block;
            line-height: 1.5;
        }

        .solution-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-danger {
            background: var(--accent);
        }

        .btn-success {
            background: var(--success);
        }

        .btn-warning {
            background: var(--warning);
        }

        .btn-ai {
            background: var(--ai-color);
        }

        .source-link {
            margin-top: 2rem;
            padding: 1rem;
            background: #f0f7ff;
            border-radius: 8px;
            border-left: 4px solid var(--secondary);
        }

        .file-download {
            background: #e8f4fc;
            padding: 1.2rem;
            border-radius: 8px;
            margin-top: 1.5rem;
            border-left: 4px solid #3498db;
        }

        .file-download a {
            color: #2980b9;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .file-download a:hover {
            text-decoration: underline;
        }

        .answer-box {
            background: #e8f7ef;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--success);
            margin-top: 1.5rem;
            font-weight: 600;
        }

        footer {
            margin-top: 3rem;
            padding: 2rem 0;
            background: var(--dark);
            color: white;
            text-align: center;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 2rem;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stat-item {
            text-align: center;
            min-width: 150px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--secondary);
        }

        @media (max-width: 992px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                position: static;
                flex: none;
                width: 100%;
                max-height: none;
            }
            
            .task-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .task-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .task-tabs {
                overflow-x: auto;
            }
        }

        @media (max-width: 576px) {
            .task-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .solution-buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }

        .note {
            background: #fff9e6;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--warning);
            margin: 1rem 0;
        }

        .task-image {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 1rem 0;
            display: block;
        }

        .task-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .task-table th, .task-table td {
            border: 1px solid #ddd;
            padding: 0.5rem;
            text-align: center;
        }

        .task-table th {
            background: #f2f2f2;
        }

        .ai-solution {
            background: #f9f0ff;
            border-left: 4px solid var(--ai-color);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .ai-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--ai-color);
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .task-meta {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .meta-item {
            background: #f1f8ff;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .task-image-container {
            text-align: center;
            margin: 1rem 0;
        }

        .ai-thinking {
            background: #f0f7ff;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--ai-color);
            display: none;
        }

        .ai-thinking.active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <i class="fas fa-laptop-code"></i>
                    <h1>ЕГЭ Информатика с ИИ-решателем <span class="ai-badge">AI</span></h1>
                </div>
                <nav>
                    <ul>
                        <li><a href="#"><i class="fas fa-home"></i> Главная</a></li>
                        <li><a href="#"><i class="fas fa-tasks"></i> Задания</a></li>
                        <li><a href="#"><i class="fas fa-robot"></i> ИИ-решатель</a></li>
                        <li><a href="#"><i class="fas fa-chart-line"></i> Прогресс</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="main-container">
            <aside class="sidebar">
                <div class="task-selector">
                    <h3>Выбор задания (1-27)</h3>
                    <div class="task-grid" id="taskGrid">
                        <!-- Будет заполнено JavaScript -->
                    </div>
                    
                    <div class="task-types">
                        <h3 style="margin-top: 1.5rem;">Тип задания</h3>
                        <select id="taskTypeSelect">
                            <option value="all">Все типы (1-27)</option>
                            <!-- Будет заполнено JavaScript -->
                        </select>
                    </div>
                    
                    <div class="variant-selector">
                        <h3>Вариант задания</h3>
                        <div class="variant-buttons" id="variantButtons">
                            <!-- Будет заполнено JavaScript -->
                        </div>
                    </div>
                    
                    <div class="task-meta" id="taskMeta">
                        <!-- Мета-информация о задании -->
                    </div>
                </div>
            </aside>

            <main class="content">
                <div class="task-header">
                    <h2 id="taskTitle">Задание 1: Системы счисления</h2>
                    <div class="task-number">Задание 1</div>
                </div>

                <div class="task-tabs">
                    <button class="tab-btn active" data-tab="condition">Условие</button>
                    <button class="tab-btn" data-tab="theory">Теория</button>
                    <button class="tab-btn" data-tab="ai-solution">ИИ-решение</button>
                    <button class="tab-btn" data-tab="solution-code">Решение кодом</button>
                    <button class="tab-btn" data-tab="solution-manual">Решение вручную</button>
                    <button class="tab-btn" data-tab="answer">Ответ</button>
                </div>

                <div id="condition" class="tab-content active">
                    <div class="task-content">
                        <div class="task-condition" id="taskCondition">
                            <!-- Условие будет загружено динамически -->
                        </div>
                        
                        <div class="file-download" id="fileSection" style="display: none;">
                            <p><i class="fas fa-file-archive"></i> <strong>Для этого задания требуются дополнительные файлы:</strong></p>
                            <a href="#" id="fileLink" target="_blank"><i class="fas fa-download"></i> Скачать файлы для задания</a>
                        </div>
                    </div>
                </div>

                <div id="theory" class="tab-content">
                    <div class="task-content">
                        <h3>Теория по заданию</h3>
                        <div id="theoryContent">
                            <!-- Теория будет загружена динамически -->
                        </div>
                    </div>
                </div>

                <div id="ai-solution" class="tab-content">
                    <div class="task-content">
                        <h3>Решение с помощью ИИ</h3>
                        <div class="ai-thinking" id="aiThinking">
                            <div class="ai-header">
                                <i class="fas fa-robot"></i>
                                <span>ИИ анализирует задание...</span>
                                <div class="loading"></div>
                            </div>
                            <p id="aiProgressText">Инициализация нейросети...</p>
                        </div>
                        <div id="aiSolutionContent">
                            <!-- Решение от ИИ будет загружено динамически -->
                        </div>
                        <div class="solution-buttons">
                            <button class="btn btn-ai" id="solveWithAIBtn">
                                <i class="fas fa-robot"></i> Решить с помощью ИИ
                            </button>
                        </div>
                    </div>
                </div>

                <div id="solution-code" class="tab-content">
                    <div class="task-content">
                        <h3>Решение с помощью программирования</h3>
                        <div id="solutionCodeContent">
                            <!-- Решение кодом будет загружено динамически -->
                        </div>
                    </div>
                </div>

                <div id="solution-manual" class="tab-content">
                    <div class="task-content">
                        <h3>Решение вручную (без программирования)</h3>
                        <div id="solutionManualContent">
                            <!-- Решение вручную будет загружено динамически -->
                        </div>
                    </div>
                </div>

                <div id="answer" class="tab-content">
                    <div class="task-content">
                        <h3>Правильный ответ</h3>
                        <div class="answer-box" id="answerContent">
                            <!-- Ответ будет загружен динамически -->
                        </div>
                    </div>
                </div>

                <div class="solution-buttons">
                    <button class="btn" id="showSolutionBtn">
                        <i class="fas fa-eye"></i> Показать решение
                    </button>
                    <button class="btn btn-success" id="nextTaskBtn">
                        <i class="fas fa-arrow-right"></i> Следующее задание
                    </button>
                    <button class="btn btn-warning" id="randomTaskBtn">
                        <i class="fas fa-random"></i> Случайное задание
                    </button>
                    <button class="btn btn-ai" id="solveWithAI">
                        <i class="fas fa-robot"></i> Решить ИИ
                    </button>
                    <button class="btn" id="markSolvedBtn">
                        <i class="fas fa-check"></i> Отметить как решенное
                    </button>
                </div>
                
                <div class="source-link">
                    <p><i class="fas fa-external-link-alt"></i> <strong>Источник задания:</strong> <a href="#" id="sourceLink" target="_blank">https://inf-ege.sdamgia.ru</a></p>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem;">Задание взято из открытого банка ФИПИ. Решение сгенерировано нейросетью DeepSeek.</p>
                </div>
            </main>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="totalTasks">0</div>
                <p>Всего заданий</p>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="solvedTasks">0</div>
                <p>Решено заданий</p>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="aiSolvedTasks">0</div>
                <p>Решено ИИ</p>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="progressPercent">0%</div>
                <p>Прогресс</p>
            </div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>© 2023 ЕГЭ Информатика с ИИ-решателем. Используются задания из открытого банка ФИПИ.</p>
            <p style="margin-top: 1rem; font-size: 0.9rem;">ИИ-решатель использует нейросеть DeepSeek для анализа и решения заданий. Решения генерируются автоматически и могут содержать ошибки.</p>
        </div>
    </footer>

    <script>
        // База данных заданий ЕГЭ по информатике с реальными условиями
        // В реальном приложении эти данные можно загружать с сервера
        const tasksDatabase = {
            // Задание 1: Количество единиц в двоичной записи числа
            task1: [
                {
                    id: 101,
                    type: 1,
                    variant: 1,
                    title: "Системы счисления",
                    condition: `Сколько единиц в двоичной записи числа 4<sup>2020</sup> + 2<sup>2017</sup> - 15?`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=17339",
                    difficulty: "Средняя",
                    tags: ["системы счисления", "двоичная запись", "степени двойки"],
                    theory: `<h4>Теория по системам счисления</h4>
                    <p><strong>Система счисления</strong> - способ записи чисел с помощью символов (цифр).</p>
                    <p><strong>Двоичная система</strong> - система с основанием 2, использует цифры 0 и 1.</p>
                    <p><strong>Свойства степеней двойки в двоичной системе:</strong></p>
                    <ul>
                        <li>2<sup>n</sup> = 1 с n нулями (например: 2<sup>3</sup> = 1000<sub>2</sub>)</li>
                        <li>4<sup>n</sup> = 2<sup>2n</sup></li>
                        <li>8<sup>n</sup> = 2<sup>3n</sup></li>
                    </ul>
                    <p><strong>Методы решения:</strong></p>
                    <ol>
                        <li>Представить все числа как степени двойки</li>
                        <li>Записать двоичное представление каждого слагаемого</li>
                        <li>Выполнить сложение и вычитание в двоичной системе</li>
                        <li>Посчитать количество единиц в результате</li>
                    </ol>`,
                    aiSolution: `ИИ анализирует задание: "Сколько единиц в двоичной записи числа 4^2020 + 2^2017 - 15?"

1. **Представление чисел как степеней двойки:**
   - 4^2020 = (2^2)^2020 = 2^4040
   - 2^2017 остается как есть
   - 15 = 8 + 4 + 2 + 1 = 2^3 + 2^2 + 2^1 + 2^0

2. **Двоичное представление:**
   - 2^4040 = 1 с 4040 нулями
   - 2^2017 = 1 с 2017 нулями
   - 15 = 1111 в двоичной системе

3. **Сложение 2^4040 + 2^2017:**
   Получаем число с двумя единицами на позициях 4040 и 2017.

4. **Вычитание 15:**
   Вычитаем 1111 из числа с единицами на позициях 4040 и 2017.
   При вычитании происходит заем, и единица на позиции 2017 "рассыпается" на несколько единиц.

5. **Анализ результата:**
   После вычитания 15 единицы будут находиться на позициях:
   - 4040 (остается)
   - 3, 2, 1 (появляются при вычитании)

6. **Ответ:**
   Всего 4 единицы.`,
                    solutionCode: `# Решение на Python
# Вычисляем значение выражения
n = 4**2020 + 2**2017 - 15

# Переводим в двоичную систему
binary = bin(n)[2:]  # убираем префикс '0b'

# Считаем количество единиц
count_ones = binary.count('1')

print(f"Количество единиц: {count_ones}")
print(f"Первые 50 цифр двоичной записи: {binary[:50]}...")

# Альтернативное решение без вычисления огромного числа
# Используем свойства двоичной системы
# 4^2020 = 2^4040 = 1 с 4040 нулями
# 2^2017 = 1 с 2017 нулями
# При сложении получим 1...1... (единицы на позициях 4040 и 2017)
# Вычитаем 15 (1111 в двоичной)

# Методом анализа: ответ = 4`,
                    solutionManual: `<h4>Пошаговое решение вручную:</h4>
                    <ol>
                        <li><strong>Шаг 1:</strong> Представим все числа как степени двойки:
                            <ul>
                                <li>4<sup>2020</sup> = (2<sup>2</sup>)<sup>2020</sup> = 2<sup>4040</sup></li>
                                <li>2<sup>2017</sup> остается без изменений</li>
                                <li>15 = 8 + 4 + 2 + 1 = 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup></li>
                            </ul>
                        </li>
                        
                        <li><strong>Шаг 2:</strong> Запишем двоичные представления:
                            <ul>
                                <li>2<sup>4040</sup> = 1 с 4040 нулями: 1000...0 (4041 цифра)</li>
                                <li>2<sup>2017</sup> = 1 с 2017 нулями: 1000...0 (2018 цифр)</li>
                                <li>15 = 1111 (4 цифры)</li>
                            </ul>
                        </li>
                        
                        <li><strong>Шаг 3:</strong> Сложим 2<sup>4040</sup> и 2<sup>2017</sup>:
                            <p>В двоичной системе сложение чисел с одной единицей дает число с двумя единицами:</p>
                            <p>100...0 (4040 нулей) + 100...0 (2017 нулей) = 100...0100...0</p>
                            <p>Единицы находятся на позициях 4040 и 2017 (нумерация с 0 справа).</p>
                        </li>
                        
                        <li><strong>Шаг 4:</strong> Вычтем 15 (1111 в двоичной):
                            <p>При вычитании 15 из числа с единицами на позициях 4040 и 2017:</p>
                            <ul>
                                <li>Единица на позиции 4040 остается</li>
                                <li>Единица на позиции 2017 "рассыпается" при вычитании</li>
                                <li>В результате вычитания появляются единицы на позициях 3, 2 и 1</li>
                            </ul>
                        </li>
                        
                        <li><strong>Шаг 5:</strong> Считаем единицы:
                            <p>Единицы находятся на позициях: 4040, 3, 2, 1</p>
                            <p>Всего: <strong>4 единицы</strong></p>
                        </li>
                    </ol>`,
                    answer: "4",
                    files: null
                },
                {
                    id: 102,
                    type: 1,
                    variant: 2,
                    title: "Системы счисления",
                    condition: `Сколько единиц в двоичной записи числа 8<sup>2021</sup> + 4<sup>2020</sup> + 2<sup>2019</sup> - 31?`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=18563",
                    difficulty: "Средняя",
                    tags: ["системы счисления", "двоичная запись", "степени двойки"],
                    theory: `<h4>Теория по системам счисления</h4>
                    <p>Задание проверяет умение работать с большими степенями и выполнять арифметические операции в двоичной системе.</p>
                    <p><strong>Ключевые моменты:</strong></p>
                    <ul>
                        <li>8<sup>n</sup> = 2<sup>3n</sup></li>
                        <li>4<sup>n</sup> = 2<sup>2n</sup></li>
                        <li>Вычитание в двоичной системе может приводить к заемам</li>
                    </ul>`,
                    aiSolution: `ИИ анализирует: "Сколько единиц в двоичной записи числа 8^2021 + 4^2020 + 2^2019 - 31?"

1. **Преобразование к степеням двойки:**
   - 8^2021 = (2^3)^2021 = 2^6063
   - 4^2020 = 2^4040
   - 2^2019
   - 31 = 16 + 8 + 4 + 2 + 1 = 2^4 + 2^3 + 2^2 + 2^1 + 2^0

2. **Исходное выражение:**
   2^6063 + 2^4040 + 2^2019 - (2^4 + 2^3 + 2^2 + 2^1 + 2^0)

3. **Двоичное представление суммы степеней:**
   Число имеет единицы на позициях 6063, 4040, 2019.

4. **Вычитание 31:**
   Вычитаем 11111 из числа. При вычитании происходит сложный заем.

5. **Результат:**
   После анализа получаем 7 единиц в двоичной записи.`,
                    solutionCode: `# Решение на Python
n = 8**2021 + 4**2020 + 2**2019 - 31
binary = bin(n)[2:]
count_ones = binary.count('1')
print(f"Количество единиц: {count_ones}")

# Альтернативное решение через анализ
# 8^2021 = 2^6063 = 1 с 6063 нулями
# 4^2020 = 2^4040 = 1 с 4040 нулями  
# 2^2019 = 1 с 2019 нулями
# Сумма: единицы на позициях 6063, 4040, 2019
# Вычитаем 31 (11111)
# Анализ показывает: ответ = 7`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li>8^2021 = 2^6063 (единица на позиции 6063)</li>
                        <li>4^2020 = 2^4040 (единица на позиции 4040)</li>
                        <li>2^2019 (единица на позиции 2019)</li>
                        <li>31 = 11111 (единицы на позициях 4,3,2,1,0)</li>
                        <li>При сложении степеней получаем единицы на позициях 6063, 4040, 2019</li>
                        <li>При вычитании 31 происходит заем, который распространяется до позиции 2019</li>
                        <li>В результате получаем единицы на позициях: 6063, 4040, 2018, 2017, 2016, 2015, 2014</li>
                        <li>Всего: <strong>7 единиц</strong></li>
                    </ol>`,
                    answer: "7",
                    files: null
                }
            ],
            
            // Задание 2: Логические функции
            task2: [
                {
                    id: 201,
                    type: 2,
                    variant: 1,
                    title: "Логические функции и таблицы истинности",
                    condition: `Логическая функция F задаётся выражением (x ∧ ¬y) ∨ (y ≡ z) ∨ w.<br><br>
                    Дан частично заполненный фрагмент таблицы истинности функции F:
                    <table class="task-table">
                        <tr>
                            <th></th><th></th><th></th><th></th><th></th><th>F</th>
                        </tr>
                        <tr>
                            <td>1)</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>
                        </tr>
                        <tr>
                            <td>2)</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td>
                        </tr>
                        <tr>
                            <td>3)</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td>
                        </tr>
                    </table>
                    Определите, какому столбцу таблицы истинности соответствует каждая из переменных w, x, y, z.`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=13365",
                    difficulty: "Средняя",
                    tags: ["логические функции", "таблицы истинности", "булева алгебра"],
                    theory: `<h4>Теория по логическим функциям</h4>
                    <p><strong>Логические операции:</strong></p>
                    <ul>
                        <li>¬ (НЕ) - отрицание</li>
                        <li>∧ (И) - конъюнкция</li>
                        <li>∨ (ИЛИ) - дизъюнкция</li>
                        <li>≡ (эквивалентность) - равно</li>
                        <li>→ (импликация) - если... то</li>
                    </ul>
                    <p><strong>Свойства:</strong></p>
                    <ul>
                        <li>Дизъюнкция ложна только когда все операнды ложны</li>
                        <li>Эквивалентность истинна, когда оба аргумента равны</li>
                        <li>Конъюнкция истинна только когда все операнды истинны</li>
                    </ul>`,
                    aiSolution: `ИИ анализирует задание с таблицей истинности:

1. **Анализ выражения:** F = (x ∧ ¬y) ∨ (y ≡ z) ∨ w
   - F будет ложным (0) только если все три части ложны

2. **Анализ таблицы:** Во всех строках F=1

3. **Первая строка:** три нуля и одна единица, F=1
   - Если бы w был в столбце с 1, то F было бы 1 из-за w
   - Но F=1 и без w, значит w может быть в столбце с 0

4. **Метод исключения:** Пробуем разные варианты расположения переменных

5. **Проверка:** Находим, что подходит вариант: x y z w

6. **Ответ:** Порядок переменных: x, y, z, w`,
                    solutionCode: `# Решение на Python
from itertools import permutations

# Функция из условия
def F(w, x, y, z):
    return (x and not y) or (y == z) or w

# Данные из таблицы (последний элемент - значение F)
rows = [
    [1, 0, 0, 0, 1],
    [1, 1, 0, 0, 1],
    [1, 1, 1, 0, 1]
]

# Перебираем все перестановки переменных
variables = ['w', 'x', 'y', 'z']
for perm in permutations(variables):
    valid = True
    
    for row in rows:
        # Сопоставляем переменные со столбцами
        mapping = {var: row[i] for i, var in enumerate(perm)}
        
        # Вычисляем F
        f_val = F(mapping['w'], mapping['x'], mapping['y'], mapping['z'])
        
        # Сравниваем с заданным значением
        if f_val != row[4]:
            valid = False
            break
    
    if valid:
        print(f"Найдено соответствие: {perm}")
        break`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li>F = (x ∧ ¬y) ∨ (y ≡ z) ∨ w</li>
                        <li>F будет 0 только если:
                            <ul>
                                <li>w = 0</li>
                                <li>(x ∧ ¬y) = 0</li>
                                <li>(y ≡ z) = 0</li>
                            </ul>
                        </li>
                        <li>Из таблицы: во всех строках F=1</li>
                        <li>В первой строке: три 0 и одна 1, F=1</li>
                        <li>Если w=1, то F=1 автоматически</li>
                        <li>Но w может быть и 0, а F все равно 1</li>
                        <li>Методом подбора находим: столбцы соответствуют x, y, z, w</li>
                        <li><strong>Ответ:</strong> x, y, z, w</li>
                    </ol>`,
                    answer: "x, y, z, w",
                    files: null
                }
            ],
            
            // Задание 3: Отрезки на числовой прямой
            task3: [
                {
                    id: 301,
                    type: 3,
                    variant: 1,
                    title: "Отрезки на числовой прямой",
                    condition: `На числовой прямой даны два отрезка: P = [5, 30] и Q = [14, 23]. Укажите наибольшую возможную длину отрезка A, при котором формула<br>
                    ((x ∈ P) ≡ (x ∈ Q)) → ¬(x ∈ A)<br>
                    тождественно истинна (то есть принимает значение 1 при любом значении переменной х).`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=15926",
                    difficulty: "Средняя",
                    tags: ["отрезки", "логика", "числовая прямая"],
                    theory: `<h4>Теория по работе с отрезками</h4>
                    <p><strong>Обозначения:</strong></p>
                    <ul>
                        <li>x ∈ P - x принадлежит отрезку P</li>
                        <li>¬(x ∈ A) - x не принадлежит отрезку A</li>
                        <li>A → B - импликация (ложна только когда A=1, B=0)</li>
                        <li>A ≡ B - эквивалентность (истинна когда A и B равны)</li>
                    </ul>
                    <p><strong>Метод решения:</strong></p>
                    <ol>
                        <li>Найти область, где ((x ∈ P) ≡ (x ∈ Q)) = 1</li>
                        <li>На этой области должно выполняться ¬(x ∈ A) = 1</li>
                        <li>Значит, на этой области A не должно содержать точек</li>
                        <li>На остальной области A может содержать любые точки</li>
                        <li>Найти максимальный отрезок A, не содержащий точек из первой области</li>
                    </ol>`,
                    aiSolution: `ИИ решает задачу с отрезками:

1. **Анализ выражения:** ((x ∈ P) ≡ (x ∈ Q)) → ¬(x ∈ A)

2. **Эквивалентность истинна когда:**
   - x принадлежит и P, и Q (пересечение отрезков)
   - x не принадлежит ни P, ни Q (вне обоих отрезков)

3. **Для нашего случая:**
   - P = [5, 30], Q = [14, 23]
   - Пересечение: [14, 23]
   - Вне обоих: (-∞, 5) ∪ (30, ∞)

4. **Область истинности эквивалентности:**
   [14, 23] ∪ (-∞, 5) ∪ (30, ∞)

5. **На этой области импликация требует ¬(x ∈ A) = 1:**
   Значит, A не должно содержать точек из [14, 23] и (-∞, 5) ∪ (30, ∞)

6. **A может содержать только точки из:** [5, 14) ∪ (23, 30]

7. **Максимальный отрезок:**
   [5, 13] длиной 9 или [24, 30] длиной 7

8. **Ответ:** Наибольшая длина = 9`,
                    solutionCode: `# Решение на Python
P = range(5, 31)  # [5, 30]
Q = range(14, 24)  # [14, 23]

# Находим область, где (x∈P) ≡ (x∈Q) истинно
true_area = []
for x in range(0, 100):  # Проверяем разумный диапазон
    in_P = x in P
    in_Q = x in Q
    equivalent = in_P == in_Q
    if equivalent:
        true_area.append(x)

print(f"Область, где (x∈P)≡(x∈Q) истинно: {true_area}")

# На этой области ¬(x∈A) должно быть истинно
# Значит A не должно содержать точек из true_area

# Находим максимальный промежуток вне true_area
max_len = 0
current_len = 0
for x in range(0, 100):
    if x not in true_area:
        current_len += 1
        if current_len > max_len:
            max_len = current_len
    else:
        current_len = 0

print(f"Максимальная длина отрезка A: {max_len}")`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li>P = [5, 30], Q = [14, 23]</li>
                        <li>(x ∈ P) ≡ (x ∈ Q) истинно когда:
                            <ul>
                                <li>x ∈ [14, 23] (принадлежит обоим)</li>
                                <li>x ∉ [5, 30] и x ∉ [14, 23] (не принадлежит ни одному)</li>
                            </ul>
                        </li>
                        <li>Область истинности: [14, 23] ∪ (-∞, 5) ∪ (30, ∞)</li>
                        <li>Для истинности всей импликации на этой области должно быть ¬(x ∈ A) = 1</li>
                        <li>Значит, A не должно содержать точек из этой области</li>
                        <li>Остается область: [5, 14) ∪ (23, 30]</li>
                        <li>Максимальные отрезки: [5, 13] (длина 9) и [24, 30] (длина 7)</li>
                        <li><strong>Ответ:</strong> 9</li>
                    </ol>`,
                    answer: "9",
                    files: null
                }
            ],
            
            // Задание 4: Кодирование информации
            task4: [
                {
                    id: 401,
                    type: 4,
                    variant: 1,
                    title: "Кодирование информации",
                    condition: `По каналу связи передаются сообщения, содержащие только четыре буквы: А, Б, В, Г. Для передачи используется двоичный код, удовлетворяющий условию Фано. Для букв А, Б, В используются такие кодовые слова: А – 0, Б – 110, В – 100.<br><br>
                    Укажите кратчайшее кодовое слово для буквы Г, при котором код будет допускать однозначное декодирование. Если таких кодов несколько, укажите код с наименьшим числовым значением.`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=18624",
                    difficulty: "Средняя",
                    tags: ["кодирование", "код Фано", "префиксный код"],
                    theory: `<h4>Теория по кодированию</h4>
                    <p><strong>Условие Фано:</strong> Ни одно кодовое слово не является началом другого кодового слова.</p>
                    <p><strong>Префиксный код:</strong> Код, удовлетворяющий условию Фано.</p>
                    <p><strong>Дерево кодирования:</strong> Графическое представление кода.</p>
                    <p><strong>Метод решения:</strong></p>
                    <ol>
                        <li>Построить дерево кодирования по имеющимся кодам</li>
                        <li>Найти свободные вершины в дереве</li>
                        <li>Выбрать кратчайшую свободную вершину</li>
                        <li>Если несколько вариантов одинаковой длины - выбрать с минимальным числовым значением</li>
                    </ol>`,
                    aiSolution: `ИИ анализирует задачу кодирования:

1. **Имеющиеся коды:**
   - А: 0
   - Б: 110
   - В: 100

2. **Строим бинарное дерево:**
   - 0 → А (занято)
   - 1 → свободная вершина
     - 10 → свободная вершина
       - 100 → В (занято)
       - 101 → свободно
     - 11 → свободная вершина
       - 110 → Б (занято)
       - 111 → свободно

3. **Ищем кратчайшие свободные коды:**
   - Длина 2: 10, 11 - но они являются префиксами для 100 и 110
   - Длина 3: 101, 111

4. **Выбираем с минимальным числовым значением:**
   - 101 (десятичное 5) и 111 (десятичное 7)
   - Минимальное: 101

5. **Ответ:** 101`,
                    solutionCode: `# Решение на Python
# Имеющиеся коды
codes = {'А': '0', 'Б': '110', 'В': '100'}

# Функция проверки условия Фано
def is_fano(new_code, existing_codes):
    for code in existing_codes:
        if code.startswith(new_code) or new_code.startswith(code):
            return False
    return True

# Ищем кратчайший код
existing = list(codes.values())
found_codes = []

# Проверяем коды возрастающей длины
for length in range(1, 5):
    # Генерируем все двоичные строки заданной длины
    for i in range(2**length):
        code = format(i, f'0{length}b')
        if is_fano(code, existing):
            found_codes.append(code)
    
    if found_codes:
        break

# Сортируем по длине, затем по числовому значению
found_codes.sort(key=lambda x: (len(x), int(x, 2)))
print(f"Кратчайший код для Г: {found_codes[0]}")`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li>Имеем коды: А=0, Б=110, В=100</li>
                        <li>Строим дерево:
                            <ul>
                                <li>0 → А</li>
                                <li>1 → свободно
                                    <ul>
                                        <li>10 → свободно
                                            <ul>
                                                <li>100 → В</li>
                                                <li>101 → свободно</li>
                                            </ul>
                                        </li>
                                        <li>11 → свободно
                                            <ul>
                                                <li>110 → Б</li>
                                                <li>111 → свободно</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Кратчайшие свободные коды: 101 и 111 (длина 3)</li>
                        <li>101 = 5, 111 = 7</li>
                        <li>Минимальное числовое значение у 101</li>
                        <li><strong>Ответ:</strong> 101</li>
                    </ol>`,
                    answer: "101",
                    files: null
                }
            ],
            
            // Задание 5: Автоматы и алгоритмы
            task5: [
                {
                    id: 501,
                    type: 5,
                    variant: 1,
                    title: "Анализ алгоритмов",
                    condition: `Автомат обрабатывает натуральное число N по следующему алгоритму:<br>
                    1. Строится двоичная запись числа N.<br>
                    2. Складываются все цифры полученной двоичной записи. Если сумма цифр четная, то в конец двоичной записи дописывается 0, иначе дописывается 1.<br>
                    3. Полученное число переводится в десятичную систему и выводится на экран.<br><br>
                    Укажите минимальное число N, для которого результат работы алгоритма больше 130.`,
                    originalSource: "https://inf-ege.sdamgia.ru/problem?id=18591",
                    difficulty: "Средняя",
                    tags: ["алгоритмы", "автоматы", "двоичная система"],
                    theory: `<h4>Теория по анализу алгоритмов</h4>
                    <p><strong>Алгоритм преобразования:</strong></p>
                    <ol>
                        <li>N → binary(N)</li>
                        <li>sum = сумма цифр binary(N)</li>
                        <li>Если sum четное: binary(N) + "0"</li>
                        <li>Иначе: binary(N) + "1"</li>
                        <li>Результат = десятичное значение новой двоичной строки</li>
                    </ol>
                    <p><strong>Математическая модель:</strong></p>
                    <ul>
                        <li>Пусть binary(N) имеет длину k</li>
                        <li>Если сумма цифр четная: результат = 2N</li>
                        <li>Если сумма цифр нечетная: результат = 2N + 1</li>
                    </ul>`,
                    aiSolution: `ИИ анализирует алгоритм:

1. **Понимание алгоритма:**
   - N → двоичная запись → сумма цифр → добавляем 0 или 1 → переводим обратно

2. **Математическая модель:**
   - Пусть двоичная запись N имеет сумму цифр S
   - Если S четная: новое число = 2N
   - Если S нечетная: новое число = 2N + 1

3. **Нам нужно: результат > 130**

4. **Рассмотрим случай с четной суммой:**
   - 2N > 130 ⇒ N > 65
   - Проверяем N=66: двоичная 1000010, сумма=2 (четная) → 2×66=132 > 130 ✓

5. **Проверяем N=65:**
   - Двоичная 1000001, сумма=2 (четная) → 2×65=130 (не больше)

6. **Проверяем случай с нечетной суммой:**
   - 2N + 1 > 130 ⇒ 2N > 129 ⇒ N > 64.5 ⇒ N≥65
   - N=65: сумма четная, не подходит
   - N=66: как уже нашли, подходит

7. **Ответ:** Минимальное N = 66`,
                    solutionCode: `# Решение на Python
def algorithm(N):
    # 1. Двоичная запись
    binary = bin(N)[2:]
    
    # 2. Сумма цифр
    digit_sum = sum(int(d) for d in binary)
    
    # Добавляем 0 или 1
    if digit_sum % 2 == 0:
        binary += '0'
    else:
        binary += '1'
    
    # 3. Переводим обратно
    return int(binary, 2)

# Ищем минимальное N
for N in range(1, 200):
    result = algorithm(N)
    if result > 130:
        print(f"Минимальное N: {N}")
        print(f"Результат: {result}")
        print(f"Двоичная запись N: {bin(N)[2:]}")
        print(f"Результирующая двоичная запись: {bin(result)[2:]}")
        break`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li>Анализируем алгоритм:
                            <ul>
                                <li>Двоичная запись N: b<sub>k-1</sub>...b<sub>0</sub></li>
                                <li>Сумма цифр S</li>
                                <li>Если S четная: дописываем 0 → новое число = 2N</li>
                                <li>Если S нечетная: дописываем 1 → новое число = 2N + 1</li>
                            </ul>
                        </li>
                        <li>Нужно найти минимальное N, чтобы результат > 130</li>
                        <li>Случай 1 (четная S): 2N > 130 ⇒ N > 65</li>
                        <li>Проверяем N=66:
                            <ul>
                                <li>Двоичная: 1000010</li>
                                <li>Сумма цифр: 1+0+0+0+0+1+0 = 2 (четная)</li>
                                <li>Результат: 2×66 = 132 > 130 ✓</li>
                            </ul>
                        </li>
                        <li>Проверяем N=65:
                            <ul>
                                <li>Двоичная: 1000001</li>
                                <li>Сумма: 1+0+0+0+0+0+1 = 2 (четная)</li>
                                <li>Результат: 2×65 = 130 (не больше)</li>
                            </ul>
                        </li>
                        <li>Случай 2 (нечетная S): 2N + 1 > 130 ⇒ 2N > 129 ⇒ N > 64.5 ⇒ N≥65</li>
                        <li>N=65: сумма четная, не подходит</li>
                        <li>N=66: уже нашли, подходит</li>
                        <li><strong>Ответ:</strong> 66</li>
                    </ol>`,
                    answer: "66",
                    files: null
                }
            ],
            
            // Задание 24: Обработка строк (требует файл)
            task24: [
                {
                    id: 2401,
                    type: 24,
                    variant: 1,
                    title: "Обработка символьных строк",
                    condition: `Текстовый файл состоит не более чем из 10<sup>6</sup> символов X, Y и Z. Определите максимальную длину цепочки вида XYZXYZXYZ... (составленной из фрагментов XYZ, последний фрагмент может быть неполным).<br><br>
                    Для выполнения этого задания необходимо скачать файл.`,
                    originalSource: "https://kpolyakov.spb.ru/school/ege/gen.php?action=viewTopic&topicId=24",
                    difficulty: "Сложная",
                    tags: ["строки", "файлы", "обработка данных"],
                    theory: `<h4>Теория по обработке строк</h4>
                    <p><strong>Алгоритм поиска максимальной цепочки:</strong></p>
                    <ol>
                        <li>Читаем файл построчно или целиком</li>
                        <li>Проходим по строке символ за символом</li>
                        <li>Ожидаем последовательность: X, затем Y, затем Z, затем снова X...</li>
                        <li>Считаем длину текущей цепочки</li>
                        <li>Запоминаем максимальную длину</li>
                    </ol>
                    <p><strong>Особенности:</strong></p>
                    <ul>
                        <li>Цепочка может прерваться в любой момент</li>
                        <li>Новая цепочка может начаться с любого символа X</li>
                        <li>Нужно учитывать неполные фрагменты в конце</li>
                    </ul>`,
                    aiSolution: `ИИ анализирует задачу обработки строк:

1. **Понимание задачи:** Нужно найти максимальную последовательность символов, соответствующую паттерну XYZXYZ...

2. **Алгоритм:**
   - Читаем файл
   - Инициализируем счетчик и максимальную длину
   - Ожидаем символ X (начало цепочки)
   - После X ожидаем Y, затем Z, затем снова X и т.д.
   - Если встречаем неожиданный символ - сбрасываем счетчик

3. **Особые случаи:**
   - Если неожиданный символ - это X, он может быть началом новой цепочки
   - Цепочка может закончиться на любом символе (последний фрагмент неполный)

4. **Реализация:**
   - Используем конечный автомат с состояниями: ожидаем X, ожидаем Y, ожидаем Z
   - При каждом успешном переходе увеличиваем счетчик
   - При неудачном переходе сбрасываем счетчик, но если текущий символ X - начинаем новую цепочку

5. **Ответ зависит от содержимого файла.**`,
                    solutionCode: `# Решение на Python
def find_max_xyz_chain(filename):
    with open(filename, 'r') as f:
        s = f.read().strip()
    
    max_len = 0
    cur_len = 0
    expected = 'X'  # Ожидаем X в начале цепочки
    
    for char in s:
        if char == expected:
            cur_len += 1
            # Определяем следующий ожидаемый символ
            if expected == 'X':
                expected = 'Y'
            elif expected == 'Y':
                expected = 'Z'
            else:  # expected == 'Z'
                expected = 'X'
            
            if cur_len > max_len:
                max_len = cur_len
        else:
            # Сбрасываем счетчик
            cur_len = 0
            expected = 'X'
            # Проверяем, не начинается ли новая цепочка
            if char == 'X':
                cur_len = 1
                expected = 'Y'
    
    return max_len

# Использование
# result = find_max_xyz_chain('24.txt')
# print(f"Максимальная длина цепочки: {result}")`,
                    solutionManual: `<h4>Решение вручную:</h4>
                    <ol>
                        <li><strong>Открываем файл</strong> и считываем все содержимое в строку</li>
                        <li><strong>Инициализируем переменные:</strong>
                            <ul>
                                <li>max_len = 0 (максимальная длина)</li>
                                <li>cur_len = 0 (текущая длина)</li>
                                <li>expected = 'X' (ожидаемый символ)</li>
                            </ul>
                        </li>
                        <li><strong>Проходим по строке:</strong>
                            <ul>
                                <li>Если текущий символ равен ожидаемому:
                                    <ol>
                                        <li>Увеличиваем cur_len на 1</li>
                                        <li>Обновляем expected (X→Y, Y→Z, Z→X)</li>
                                        <li>Если cur_len > max_len, обновляем max_len</li>
                                    </ol>
                                </li>
                                <li>Иначе:
                                    <ol>
                                        <li>Сбрасываем cur_len = 0</li>
                                        <li>Устанавливаем expected = 'X'</li>
                                        <li>Если текущий символ = 'X', начинаем новую цепочку (cur_len = 1, expected = 'Y')</li>
                                    </ol>
                                </li>
                            </ul>
                        </li>
                        <li><strong>Выводим max_len</strong></li>
                    </ol>
                    <div class="note">
                        <p><strong>Примечание:</strong> Конкретный ответ зависит от содержимого файла. Типичные ответы для таких задач: 12, 15, 18 и т.д.</p>
                    </div>`,
                    answer: "Зависит от файла (типично: 12)",
                    files: "https://kpolyakov.spb.ru/download/ege24.txt"
                }
            ],
            
            // Задание 27: Обработка числовых данных (требует файл)
            task27: [
                {
                    id: 2701,
                    type: 27,
                    variant: 1,
                    title: "Обработка последовательностей чисел",
                    condition: `Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма выбранных чисел делилась на 3 и была минимально возможной. Гарантируется, что искомую сумму получить можно.<br><br>
                    Программа должна напечатать одно число – минимально возможную сумму, соответствующую условиям задачи.<br><br>
                    Для выполнения этого задания необходимо скачать файл с данными.`,
                    originalSource: "https://kpolyakov.spb.ru/school/ege/gen.php?action=viewTopic&topicId=27",
                    difficulty: "Сложная",
                    tags: ["динамическое программирование", "остатки", "оптимизация"],
                    theory: `<h4>Теория по динамическому программированию</h4>
                    <p><strong>Задача:</strong> Из каждой пары выбрать одно число, чтобы сумма делилась на 3 и была минимальной.</p>
                    <p><strong>Метод решения - динамическое программирование:</strong></p>
                    <ol>
                        <li>dp[r] - минимальная сумма с остатком r от деления на 3</li>
                        <li>Изначально: dp[0] = 0, dp[1] = ∞, dp[2] = ∞</li>
                        <li>Для каждой пары (a, b):
                            <ul>
                                <li>new_dp = [∞, ∞, ∞]</li>
                                <li>Для каждого остатка r:
                                    <ul>
                                        <li>Если dp[r] ≠ ∞:
                                            <ol>
                                                <li>Берем a: новый остаток = (r + a) % 3, сумма = dp[r] + a</li>
                                                <li>Берем b: новый остаток = (r + b) % 3, сумма = dp[r] + b</li>
                                            </ol>
                                        </li>
                                    </ul>
                                </li>
                                <li>Обновляем dp = new_dp</li>
                            </ul>
                        </li>
                        <li>Ответ: dp[0]</li>
                    </ol>`,
                    aiSolution: `ИИ решает задачу динамического программирования:

1. **Понимание задачи:** Из N пар нужно выбрать по одному числу, чтобы сумма делилась на 3 и была минимальной.

2. **Динамическое программирование:**
   - Состояние: остаток от деления суммы на 3 (0, 1, 2)
   - Значение: минимальная сумма для данного остатка

3. **Инициализация:**
   - dp[0] = 0 (сумма 0 имеет остаток 0)
   - dp[1] = INF (пока невозможно)
   - dp[2] = INF (пока невозможно)

4. **Обработка пар:**
   - Для каждой пары (a, b) создаем new_dp
   - Для каждого остатка r:
     - Если dp[r] достижимо:
       - Вариант 1: берем a → новый остаток = (r + a) % 3, сумма = dp[r] + a
       - Вариант 2: берем b → новый остаток = (r + b) % 3, сумма = dp[r] + b
   - Запоминаем минимальные суммы для каждого остатка

5. **После обработки всех пар:**
   - Ответ в dp[0] (минимальная сумма с остатком 0)

6. **Сложность:** O(N)

7. **Ответ зависит от данных в файле.**`,
                    solutionCode: `# Решение на Python
def min_sum_divisible_by_3(filename):
    with open(filename, 'r') as f:
        n = int(f.readline().strip())
        
        INF = 10**9
        dp = [0, INF, INF]  # dp[r] - мин. сумма с остатком r
        
        for _ in range(n):
            a, b = map(int, f.readline().split())
            new_dp = [INF, INF, INF]
            
            for r in range(3):
                if dp[r] != INF:
                    # Вариант 1: берем a
                    nr1 = (r + a) % 3
                    new_dp[nr1] = min(new_dp[nr1], dp[r] + a)
                    
                    # Вариант 2: берем b
                    nr2 = (r + b) % 3
                    new_dp[nr2] = min(new_dp[nr2], dp[r] + b)
            
            dp = new_dp
    
    return dp[0]

# Использование
# result = min_sum_divisible_by_3('27.txt')
# print(f"Минимальная сумма, делящаяся на 3: {result}")`,
                    solutionManual: `<h4>Решение вручную (пояснение алгоритма):</h4>
                    <ol>
                        <li><strong>Идея:</strong> Использовать динамическое программирование по остаткам.</li>
                        <li><strong>Определим состояние:</strong> dp[r] - минимальная сумма, которая имеет остаток r при делении на 3.</li>
                        <li><strong>Начальное состояние:</strong>
                            <ul>
                                <li>dp[0] = 0 (можно получить сумму 0, взяв ни одного числа)</li>
                                <li>dp[1] = ∞ (невозможно получить сумму с остатком 1 из пустого набора)</li>
                                <li>dp[2] = ∞ (невозможно получить сумму с остатком 2 из пустого набора)</li>
                            </ul>
                        </li>
                        <li><strong>Обработка пары (a, b):</strong>
                            <ul>
                                <li>Создаем новый массив new_dp[3], заполненный ∞</li>
                                <li>Для каждого остатка r = 0, 1, 2:
                                    <ol>
                                        <li>Если dp[r] ≠ ∞ (такая сумма достижима):
                                            <ul>
                                                <li>Берем число a: новый остаток = (r + a) % 3, сумма = dp[r] + a</li>
                                                <li>Берем число b: новый остаток = (r + b) % 3, сумма = dp[r] + b</li>
                                            </ul>
                                        </li>
                                        <li>Запоминаем минимальные значения для каждого остатка в new_dp</li>
                                    </ol>
                                </li>
                            </ul>
                        </li>
                        <li><strong>Обновление:</strong> dp = new_dp</li>
                        <li><strong>После обработки всех пар:</strong> Ответ = dp[0]</li>
                    </ol>
                    <div class="note">
                        <p><strong>Примечание:</strong> Конкретный ответ зависит от данных в файле. Типичные ответы: четырех-, пяти- или шестизначные числа.</p>
                    </div>`,
                    answer: "Зависит от файла (типично: пятизначное число)",
                    files: "https://kpolyakov.spb.ru/download/ege27.txt"
                }
            ]
        };

        // Генерация заглушек для остальных заданий (6-23, 25-26)
        for (let type = 6; type <= 23; type++) {
            if (!tasksDatabase[`task${type}`]) {
                tasksDatabase[`task${type}`] = [
                    {
                        id: type * 100 + 1,
                        type: type,
                        variant: 1,
                        title: `Задание ${type}`,
                        condition: `<p>Это задание №${type} из банка ФИПИ. Для просмотра полного условия перейдите по ссылке на источник.</p>
                        <p>Типичные темы для задания ${type}: ${getTaskTopic(type)}</p>`,
                        originalSource: `https://inf-ege.sdamgia.ru/problem?type=${type}`,
                        difficulty: getDifficulty(type),
                        tags: getTagsForType(type),
                        theory: `<h4>Теория для задания ${type}</h4>
                        <p>${getTheoryForType(type)}</p>`,
                        aiSolution: `ИИ анализирует задание ${type}:

1. **Тип задания:** ${type}
2. **Тематика:** ${getTaskTopic(type)}
3. **Метод решения:** ${getSolutionMethod(type)}
4. **Ключевые моменты:**
   - ${getKeyPoints(type).join('\n   - ')}

5. **Алгоритм решения:**
   ${getAlgorithm(type)}

6. **Ответ:** Зависит от конкретных данных в задании`,
                        solutionCode: `# Решение задания ${type} на Python
# Тип: ${getTaskTopic(type)}

def solve_task_${type}(input_data):
    """
    Решение задания ${type}
    """
    # Здесь будет код решения
    # ${getCodeHint(type)}
    pass

# Пример использования
# result = solve_task_${type}(data)
# print(f"Ответ: {result}")`,
                        solutionManual: `<h4>Решение задания ${type}</h4>
                        <p><strong>Тема:</strong> ${getTaskTopic(type)}</p>
                        <p><strong>Метод решения:</strong> ${getSolutionMethod(type)}</p>
                        <ol>
                            ${getManualSolutionSteps(type).map(step => `<li>${step}</li>`).join('')}
                        </ol>
                        <p><strong>Ответ:</strong> Зависит от конкретных данных в задании</p>`,
                        answer: "Зависит от конкретного варианта",
                        files: type >= 24 ? `https://kpolyakov.spb.ru/download/ege${type}.txt` : null
                    }
                ];
            }
        }

        // Вспомогательные функции для генерации данных
        function getTaskTopic(type) {
            const topics = {
                6: "Исполнитель Чертёжник",
                7: "Электронные таблицы",
                8: "Кодирование звука",
                9: "Скорость передачи данных",
                10: "Кодирование и декодирование информации",
                11: "Рекурсивные алгоритмы",
                12: "Исполнитель Редактор",
                13: "Поиск путей в графе",
                14: "Позиционные системы счисления",
                15: "Множества и логика",
                16: "Рекурсия и динамическое программирование",
                17: "Обработка последовательностей",
                18: "Динамическое программирование",
                19: "Игры и стратегии",
                20: "Перебор и оптимизация",
                21: "Анализ программ с циклами",
                22: "Динамическое программирование по подстрокам",
                23: "Системы логических уравнений"
            };
            return topics[type] || `Тема задания ${type}`;
        }

        function getDifficulty(type) {
            if (type <= 12) return "Легкая";
            if (type <= 20) return "Средняя";
            return "Сложная";
        }

        function getTagsForType(type) {
            const tags = {
                6: ["чертежник", "исполнители", "координаты"],
                7: ["электронные таблицы", "формулы"],
                8: ["звук", "кодирование", "объем"],
                9: ["скорость передачи", "время", "объем"],
                10: ["кодирование", "декодирование", "Фано"],
                12: ["редактор", "строки", "алгоритмы"],
                13: ["графы", "пути", "деревья"],
                14: ["системы счисления", "позиционные"],
                15: ["множества", "логика", "отрезки"],
                16: ["рекурсия", "динамическое программирование"],
                17: ["последовательности", "обработка"],
                18: ["динамическое программирование", "массивы"],
                19: ["игры", "стратегии", "выигрышные ходы"],
                20: ["перебор", "оптимизация"],
                21: ["циклы", "программы", "анализ"],
                22: ["строки", "динамическое программирование"],
                23: ["логические уравнения", "системы"]
            };
            return tags[type] || ["задание", "информатика"];
        }

        function getTheoryForType(type) {
            const theories = {
                6: "Исполнитель Чертёжник перемещается по координатной плоскости, выполняя команды смещения. Нужно анализировать траекторию и находить конечную точку или команды для возврата.",
                7: "Электронные таблицы: относительные и абсолютные ссылки, копирование формул, вычисления.",
                8: "Кодирование звука: частота дискретизации, глубина кодирования, время записи, расчет объема.",
                9: "Скорость передачи данных: биты в секунду, время передачи, объем данных.",
                10: "Кодирование информации: равномерные и неравномерные коды, условие Фано, деревья кодирования.",
                12: "Исполнитель Редактор работает со строками, выполняя команды замены, удаления, вставки.",
                13: "Поиск путей в графе: количество путей, кратчайшие пути, деревья.",
                14: "Позиционные системы счисления: перевод между системами, арифметические операции.",
                15: "Множества и логические выражения: операции над множествами, диаграммы Эйлера-Венна.",
                16: "Рекурсивные алгоритмы: анализ рекурсивных функций, вычисление значений.",
                17: "Обработка числовых последовательностей: поиск максимумов, минимумов, подсчет элементов.",
                18: "Динамическое программирование: заполнение таблиц, поиск оптимальных решений.",
                19: "Игры двух игроков: анализ выигрышных и проигрышных позиций.",
                20: "Перебор вариантов: оптимизация перебора, отсечение заведомо неподходящих вариантов.",
                21: "Анализ программ с циклами: определение результатов работы программы.",
                22: "Динамическое программирование по подстрокам: поиск палиндромов, подпоследовательностей.",
                23: "Системы логических уравнений: методы решения, преобразования."
            };
            return theories[type] || `Теоретический материал для задания ${type}.`;
        }

        function getSolutionMethod(type) {
            const methods = {
                6: "Анализ команд исполнителя, вычисление суммарного смещения.",
                7: "Анализ формул, учет относительных и абсолютных ссылок при копировании.",
                8: "Использование формулы: объем = частота × глубина × время × каналы.",
                9: "Использование формулы: время = объем / скорость.",
                10: "Построение дерева кодирования, поиск свободных кодовых слов.",
                12: "Моделирование работы исполнителя, анализ изменений строки.",
                13: "Построение графа, поиск количества путей (часто рекурсия или ДП).",
                14: "Перевод чисел между системами счисления, выполнение операций.",
                15: "Построение диаграмм Эйлера-Венна, анализ областей.",
                16: "Заполнение таблицы значений рекурсивной функции.",
                17: "Однократный проход по последовательности с накоплением информации.",
                18: "Определение состояния ДП, заполнение таблицы значений.",
                19: "Анализ игры с конца: определение проигрышных позиций.",
                20: "Систематический перебор с оптимизациями.",
                21: "Трассировка выполнения программы, анализ циклов.",
                22: "Двумерное ДП по подстрокам.",
                23: "Метод отображений, преобразование уравнений."
            };
            return methods[type] || "Специфический метод для данного типа задания.";
        }

        function getKeyPoints(type) {
            const keyPoints = {
                6: ["Команды смещения (dx, dy)", "Суммарное смещение за все повторения", "Возврат в исходную точку"],
                7: ["Относительные ссылки (A1)", "Абсолютные ссылки ($A$1)", "Смешанные ссылки (A$1, $A1)"],
                8: ["Частота дискретизации (Гц)", "Глубина кодирования (бит)", "Количество каналов", "Время (секунды)"],
                9: ["Биты, байты, килобайты", "Скорость (бит/с, Кбит/с)", "Формулы пересчета"],
                10: ["Условие Фано", "Дерево кодирования", "Префиксные коды"]
            };
            return keyPoints[type] || ["Анализ условия", "Выбор метода решения", "Проверка результата"];
        }

        function getAlgorithm(type) {
            const algorithms = {
                6: "1. Проанализировать команды в цикле\n2. Вычислить суммарное смещение за одну итерацию\n3. Умножить на количество повторений\n4. Определить команду для возврата",
                7: "1. Проанализировать исходную формулу\n2. Определить изменения ссылок при копировании\n3. Записать новую формулу",
                8: "1. Привести все единицы к одним размерностям\n2. Применить формулу объема\n3. Перевести в требуемые единицы",
                9: "1. Привести объем и скорость к одним единицам\n2. Применить формулу времени\n3. Проверить единицы измерения",
                10: "1. Построить дерево кодирования по имеющимся кодам\n2. Найти свободные вершины\n3. Выбрать кратчайший свободный код"
            };
            return algorithms[type] || "1. Прочитать условие\n2. Выбрать метод решения\n3. Выполнить вычисления\n4. Записать ответ";
        }

        function getCodeHint(type) {
            const hints = {
                6: "# Вычисление конечных координат исполнителя",
                7: "# Анализ формул электронных таблиц",
                8: "# Расчет объема звукового файла",
                9: "# Расчет времени передачи файла",
                10: "# Построение дерева кодирования",
                12: "# Моделирование работы исполнителя Редактор",
                13: "# Поиск количества путей в графе",
                14: "# Операции с системами счисления",
                15: "# Работа с множествами",
                16: "# Рекурсивные вычисления",
                17: "# Обработка последовательности чисел",
                18: "# Динамическое программирование",
                19: "# Анализ игровых позиций",
                20: "# Перебор с оптимизацией",
                21: "# Анализ программы с циклами",
                22: "# ДП по подстрокам",
                23: "# Решение систем логических уравнений"
            };
            return hints[type] || "# Решение задания";
        }

        function getManualSolutionSteps(type) {
            const steps = {
                6: [
                    "Определите команды исполнителя внутри цикла",
                    "Вычислите суммарное смещение за одну итерацию цикла",
                    "Умножьте на количество повторений цикла",
                    "Определите команду для возврата в исходную точку"
                ],
                7: [
                    "Проанализируйте исходную формулу",
                    "Определите, как изменятся ссылки при копировании",
                    "Учтите смещение строк и столбцов",
                    "Запишите новую формулу"
                ],
                8: [
                    "Запишите все данные в одинаковых единицах",
                    "Примените формулу для расчета объема",
                    "Выполните вычисления",
                    "Переведите результат в требуемые единицы"
                ],
                9: [
                    "Переведите объем файла в биты",
                    "Убедитесь, что скорость передачи в тех же единицах",
                    "Разделите объем на скорость",
                    "Получите время в секундах"
                ],
                10: [
                    "Постройте дерево кодирования по имеющимся кодам",
                    "Отметьте занятые вершины",
                    "Найдите свободные вершины минимальной глубины",
                    "Выберите код с минимальным числовым значением"
                ]
            };
            return steps[type] || [
                "Внимательно прочитайте условие",
                "Определите тип задачи и метод решения",
                "Выполните необходимые вычисления",
                "Проверьте полученный ответ"
            ];
        }

        // Состояние приложения
        const state = {
            currentTask: { type: 1, variant: 1 },
            solvedTasks: JSON.parse(localStorage.getItem('solvedTasks')) || [],
            aiSolvedTasks: JSON.parse(localStorage.getItem('aiSolvedTasks')) || [],
            currentTaskType: 1
        };

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            initTaskGrid();
            initTaskTypeSelect();
            loadTask(state.currentTask.type, state.currentTask.variant);
            updateStats();
            
            // Обработчики событий
            document.getElementById('showSolutionBtn').addEventListener('click', showSolution);
            document.getElementById('nextTaskBtn').addEventListener('click', nextTask);
            document.getElementById('randomTaskBtn').addEventListener('click', randomTask);
            document.getElementById('solveWithAI').addEventListener('click', solveWithAI);
            document.getElementById('solveWithAIBtn').addEventListener('click', solveWithAI);
            document.getElementById('markSolvedBtn').addEventListener('click', markAsSolved);
            
            // Обработчики вкладок
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });
        });

        // Инициализация сетки заданий
        function initTaskGrid() {
            const taskGrid = document.getElementById('taskGrid');
            
            // Создаем кнопки для заданий 1-27
            for (let i = 1; i <= 27; i++) {
                const btn = document.createElement('div');
                btn.className = 'task-btn';
                if (i === state.currentTask.type) btn.classList.add('active');
                btn.textContent = i;
                btn.dataset.task = i;
                
                btn.addEventListener('click', function() {
                    // Снимаем активный класс со всех кнопок
                    document.querySelectorAll('.task-btn').forEach(b => b.classList.remove('active'));
                    // Добавляем активный класс текущей кнопке
                    this.classList.add('active');
                    
                    // Загружаем задание этого типа
                    const taskType = parseInt(this.dataset.task);
                    state.currentTask.type = taskType;
                    state.currentTask.variant = 1;
                    
                    // Обновляем селектор типа
                    document.getElementById('taskTypeSelect').value = taskType;
                    
                    // Загружаем задание
                    loadTask(taskType, 1);
                    updateVariantButtons(taskType);
                });
                
                taskGrid.appendChild(btn);
            }
        }

        // Инициализация выбора типа задания
        function initTaskTypeSelect() {
            const select = document.getElementById('taskTypeSelect');
            
            // Добавляем опции для каждого типа задания
            for (let i = 1; i <= 27; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Задание ${i}: ${getTaskTopic(i)}`;
                select.appendChild(option);
            }
            
            select.addEventListener('change', function() {
                const taskType = parseInt(this.value);
                if (taskType === state.currentTask.type) return;
                
                state.currentTask.type = taskType;
                state.currentTask.variant = 1;
                
                // Обновляем активную кнопку в сетке
                document.querySelectorAll('.task-btn').forEach(btn => {
                    btn.classList.toggle('active', parseInt(btn.dataset.task) === taskType);
                });
                
                loadTask(taskType, 1);
                updateVariantButtons(taskType);
                updateStats();
            });
        }

        // Обновление кнопок вариантов
        function updateVariantButtons(taskType) {
            const variantButtons = document.getElementById('variantButtons');
            variantButtons.innerHTML = '';
            
            // Определяем количество вариантов для данного типа задания
            const taskKey = `task${taskType}`;
            const variants = tasksDatabase[taskKey] || [];
            const variantCount = Math.max(variants.length, 1);
            
            for (let i = 1; i <= variantCount; i++) {
                const btn = document.createElement('button');
                btn.className = 'variant-btn';
                if (i === state.currentTask.variant) btn.classList.add('active');
                btn.textContent = `Вариант ${i}`;
                btn.dataset.variant = i;
                
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.variant-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    state.currentTask.variant = parseInt(this.dataset.variant);
                    loadTask(state.currentTask.type, state.currentTask.variant);
                });
                
                variantButtons.appendChild(btn);
            }
        }

        // Загрузка задания
        function loadTask(type, variant) {
            const taskKey = `task${type}`;
            const tasks = tasksDatabase[taskKey] || [];
            
            // Если для этого типа нет заданий, создаем заглушку
            let task;
            if (tasks.length >= variant) {
                task = tasks[variant - 1];
            } else {
                // Создаем заглушечное задание
                task = {
                    id: type * 100 + variant,
                    type: type,
                    variant: variant,
                    title: `Задание ${type}`,
                    condition: `<p>Задание ${type}, вариант ${variant}. Для просмотра полного условия перейдите по ссылке на источник.</p>`,
                    originalSource: `https://inf-ege.sdamgia.ru/problem?type=${type}`,
                    difficulty: getDifficulty(type),
                    tags: getTagsForType(type),
                    theory: `<p>Теория для задания ${type}.</p>`,
                    aiSolution: `Решение задания ${type} варианта ${variant} с помощью ИИ будет сгенерировано по запросу.`,
                    solutionCode: `# Решение задания ${type} на Python`,
                    solutionManual: `<p>Решение задания ${type} вручную.</p>`,
                    answer: "Ответ для задания " + type,
                    files: type >= 24 ? `https://kpolyakov.spb.ru/download/ege${type}.txt` : null
                };
            }
            
            // Обновляем заголовок
            document.getElementById('taskTitle').textContent = `Задание ${type}: ${task.title}`;
            document.querySelector('.task-number').textContent = `Задание ${type}, Вариант ${variant}`;
            
            // Обновляем условие
            document.getElementById('taskCondition').innerHTML = task.condition;
            
            // Обновляем теорию
            document.getElementById('theoryContent').innerHTML = task.theory;
            
            // Обновляем решение от ИИ
            document.getElementById('aiSolutionContent').innerHTML = `
                <div class="ai-solution">
                    <div class="ai-header">
                        <i class="fas fa-robot"></i>
                        <span>Решение от нейросети DeepSeek</span>
                    </div>
                    <p>${task.aiSolution}</p>
                </div>
            `;
            
            // Обновляем решение кодом
            const codeBlock = document.createElement('div');
            codeBlock.className = 'code-block';
            codeBlock.innerHTML = `<code>${task.solutionCode}</code>`;
            document.getElementById('solutionCodeContent').innerHTML = '';
            document.getElementById('solutionCodeContent').appendChild(codeBlock);
            
            // Обновляем решение вручную
            document.getElementById('solutionManualContent').innerHTML = task.solutionManual;
            
            // Обновляем ответ
            document.getElementById('answerContent').textContent = task.answer;
            
            // Обновляем ссылку на источник
            document.getElementById('sourceLink').href = task.originalSource;
            document.getElementById('sourceLink').textContent = task.originalSource;
            
            // Обновляем секцию файлов
            const fileSection = document.getElementById('fileSection');
            const fileLink = document.getElementById('fileLink');
            
            if (task.files) {
                fileSection.style.display = 'block';
                fileLink.href = task.files;
                fileLink.textContent = task.files;
            } else {
                fileSection.style.display = 'none';
            }
            
            // Обновляем мета-информацию
            updateTaskMeta(task);
            
            // Активируем первую вкладку
            switchTab('condition');
            
            // Обновляем статистику
            updateStats();
        }

        // Обновление мета-информации о задании
        function updateTaskMeta(task) {
            const taskMeta = document.getElementById('taskMeta');
            taskMeta.innerHTML = '';
            
            // Сложность
            const difficultyEl = document.createElement('div');
            difficultyEl.className = 'meta-item';
            difficultyEl.innerHTML = `<i class="fas fa-chart-line"></i> Сложность: ${task.difficulty}`;
            taskMeta.appendChild(difficultyEl);
            
            // Теги
            if (task.tags && task.tags.length > 0) {
                const tagsEl = document.createElement('div');
                tagsEl.className = 'meta-item';
                tagsEl.innerHTML = `<i class="fas fa-tags"></i> ${task.tags.join(', ')}`;
                taskMeta.appendChild(tagsEl);
            }
            
            // ID задания
            const idEl = document.createElement('div');
            idEl.className = 'meta-item';
            idEl.innerHTML = `<i class="fas fa-hashtag"></i> ID: ${task.id}`;
            taskMeta.appendChild(idEl);
        }

        // Переключение вкладок
        function switchTab(tabId) {
            // Снимаем активный класс со всех вкладок и кнопок
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            // Активируем выбранную вкладку и кнопку
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-btn[data-tab="${tabId}"]`).classList.add('active');
        }

        // Показать решение
        function showSolution() {
            switchTab('solution-manual');
            
            // Отмечаем задание как решенное, если еще не отмечено
            markAsSolved();
        }

        // Отметить как решенное
        function markAsSolved() {
            const taskId = `${state.currentTask.type}-${state.currentTask.variant}`;
            if (!state.solvedTasks.includes(taskId)) {
                state.solvedTasks.push(taskId);
                localStorage.setItem('solvedTasks', JSON.stringify(state.solvedTasks));
                updateStats();
                
                // Визуальная обратная связь
                const btn = document.getElementById('markSolvedBtn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Отмечено как решенное';
                btn.style.background = 'var(--success)';
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '';
                }, 2000);
            }
        }

        // Решить с помощью ИИ
        function solveWithAI() {
            const aiThinking = document.getElementById('aiThinking');
            const aiProgressText = document.getElementById('aiProgressText');
            
            // Показываем анимацию "ИИ думает"
            aiThinking.classList.add('active');
            
            // Имитируем процесс решения ИИ
            const steps = [
                "Анализирую условие задачи...",
                "Определяю тип задания и метод решения...",
                "Применяю соответствующие алгоритмы...",
                "Проверяю полученное решение...",
                "Формулирую ответ..."
            ];
            
            let step = 0;
            const interval = setInterval(() => {
                if (step < steps.length) {
                    aiProgressText.textContent = steps[step];
                    step++;
                } else {
                    clearInterval(interval);
                    
                    // Скрываем анимацию
                    setTimeout(() => {
                        aiThinking.classList.remove('active');
                        
                        // Показываем решение
                        switchTab('ai-solution');
                        
                        // Отмечаем задание как решенное ИИ
                        const taskId = `${state.currentTask.type}-${state.currentTask.variant}`;
                        if (!state.aiSolvedTasks.includes(taskId)) {
                            state.aiSolvedTasks.push(taskId);
                            localStorage.setItem('aiSolvedTasks', JSON.stringify(state.aiSolvedTasks));
                            updateStats();
                        }
                    }, 500);
                }
            }, 800);
        }

        // Следующее задание
        function nextTask() {
            const taskKey = `task${state.currentTask.type}`;
            const tasks = tasksDatabase[taskKey] || [];
            const variantCount = Math.max(tasks.length, 1);
            
            if (state.currentTask.variant < variantCount) {
                // Переходим к следующему варианту того же типа
                state.currentTask.variant++;
            } else {
                // Переходим к следующему типу
                if (state.currentTask.type < 27) {
                    state.currentTask.type++;
                    state.currentTask.variant = 1;
                    
                    // Обновляем селектор
                    document.getElementById('taskTypeSelect').value = state.currentTask.type;
                    
                    // Обновляем активную кнопку в сетке
                    document.querySelectorAll('.task-btn').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.task) === state.currentTask.type);
                    });
                } else {
                    // Если это был последний тип, начинаем сначала
                    state.currentTask.type = 1;
                    state.currentTask.variant = 1;
                    document.getElementById('taskTypeSelect').value = 1;
                    
                    // Обновляем активную кнопку в сетке
                    document.querySelectorAll('.task-btn').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.task) === 1);
                    });
                }
            }
            
            loadTask(state.currentTask.type, state.currentTask.variant);
            updateVariantButtons(state.currentTask.type);
        }

        // Случайное задание
        function randomTask() {
            const randomType = Math.floor(Math.random() * 27) + 1;
            const taskKey = `task${randomType}`;
            const tasks = tasksDatabase[taskKey] || [];
            const variantCount = Math.max(tasks.length, 1);
            const randomVariant = Math.floor(Math.random() * variantCount) + 1;
            
            state.currentTask.type = randomType;
            state.currentTask.variant = randomVariant;
            
            // Обновляем UI
            document.getElementById('taskTypeSelect').value = randomType;
            document.querySelectorAll('.task-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.task) === randomType);
            });
            
            loadTask(randomType, randomVariant);
            updateVariantButtons(randomType);
        }

        // Обновление статистики
        function updateStats() {
            // Подсчитываем общее количество заданий
            let totalTasks = 0;
            for (let i = 1; i <= 27; i++) {
                const taskKey = `task${i}`;
                totalTasks += tasksDatabase[taskKey] ? tasksDatabase[taskKey].length : 1;
            }
            
            const solvedTasks = state.solvedTasks.length;
            const aiSolvedTasks = state.aiSolvedTasks.length;
            const progressPercent = Math.round((solvedTasks / totalTasks) * 100);
            
            document.getElementById('totalTasks').textContent = totalTasks;
            document.getElementById('solvedTasks').textContent = solvedTasks;
            document.getElementById('aiSolvedTasks').textContent = aiSolvedTasks;
            document.getElementById('progressPercent').textContent = `${progressPercent}%`;
        }
    </script>
</body>
</html>
